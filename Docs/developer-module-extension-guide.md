# Gu√≠a de Desarrollo: Extensi√≥n y Comunicaci√≥n de M√≥dulos

## üéØ **Objetivo**

Esta gu√≠a te ayudar√° a **comunicar m√≥dulos** entre s√≠ en el GesPrender Framework usando el sistema de comunicaci√≥n inter-modular.

## üî• **Casos de Uso Comunes**

- **Enviar WhatsApp** cuando se crea un cliente
- **Cobrar cuotas autom√°ticamente** con MercadoPago
- **Enviar emails** cuando hay eventos importantes
- **Sincronizar datos** entre m√≥dulos
- **Triggers autom√°ticos** entre funcionalidades

---

## üìã **Prerequisitos**

Antes de empezar, aseg√∫rate de que:

1. ‚úÖ **El framework est√° funcionando** correctamente
2. ‚úÖ **Los m√≥dulos b√°sicos existen** en `Backoffice/src/Modules/`
3. ‚úÖ **El sistema de comunicaci√≥n est√° inicializado** (ver integraci√≥n con Kernel)

---

## üöÄ **Paso 1: Crear un M√≥dulo Nuevo con Comunicaci√≥n**

### 1.1 Crear la Estructura del M√≥dulo

```bash
# Estructura b√°sica DDD del m√≥dulo
mkdir -p Backoffice/src/Modules/MiModulo/Application
mkdir -p Backoffice/src/Modules/MiModulo/Domain  
mkdir -p Backoffice/src/Modules/MiModulo/Infrastructure
mkdir -p Backoffice/src/Modules/MiModulo/Design
```

### 1.2 Crear el Repository (Infrastructure)

```php
// Backoffice/src/Modules/MiModulo/Infrastructure/MiModuloRepository.php
<?php #GesPrender Core Framework
declare(strict_types=1);
namespace Backoffice\Modules\MiModulo\Infrastructure;

use Core\Contracts\RepositoryAbstract;

class MiModuloRepository extends RepositoryAbstract {
    
    public function findAll(): array
    {
        // Implementar l√≥gica de consulta
        return [];
    }
    
    public function save(array $data): bool
    {
        // Implementar l√≥gica de guardado
        return true;
    }
    
    public function findById(int $id): ?array
    {
        // Implementar l√≥gica de b√∫squeda
        return null;
    }
}
```

### 1.3 Crear Casos de Uso (Application)

```php
// Backoffice/src/Modules/MiModulo/Application/SetElement.php
<?php #GesPrender Core Framework
declare(strict_types=1);
namespace Backoffice\Modules\MiModulo\Application;

use Backoffice\Modules\MiModulo\Infrastructure\MiModuloRepository;
use Core\Services\JsonResponse;
use Core\Contracts\Traits\TraitRequest;

final class SetElement extends MiModuloRepository
{
    use TraitRequest;

    public function __construct() {
        $this->run();
    }

    # [Route('/mimodulo/create', name: 'MiModuloCreate', methods: 'POST')]
    # useMiddleware
    public function run(): JsonResponse
    {
        try {
            // Tu l√≥gica de negocio aqu√≠
            $data = $this->getRequestData();
            $result = $this->save($data);
            
            return new JsonResponse([
                'status' => true,
                'message' => 'Element created successfully',
                'data' => $result
            ], 201);
            
        } catch (\Throwable $th) {
            return self::ExceptionResponse($th, 'SetElement:action');
        }
    }
    
    private function getRequestData(): array
    {
        return [
            'name' => $_POST['name'] ?? '',
            'description' => $_POST['description'] ?? ''
        ];
    }
}
```

### 1.4 Crear la Clase de Comunicaci√≥n en Infrastructure (‚≠ê CLAVE)

```bash
# Crear directorio de comunicaci√≥n
mkdir -p Backoffice/src/Modules/MiModulo/Infrastructure/Communication
```

```php
// Backoffice/src/Modules/MiModulo/Infrastructure/Communication/ModuleCommunication.php
<?php #GesPrender Core Framework
declare(strict_types=1);
namespace Backoffice\Modules\MiModulo\Infrastructure\Communication;

use GesPrender\Communication\ModuleCommunicationInterface;
use GesPrender\Communication\ModuleEventDispatcher;
use GesPrender\Communication\ModuleServiceRegistry;
use GesPrender\Communication\ModuleHookSystem;
use Backoffice\Modules\MiModulo\Infrastructure\MiModuloRepository;

class ModuleCommunication implements ModuleCommunicationInterface
{
    private MiModuloRepository $repository;
    
    public function __construct()
    {
        $this->repository = new MiModuloRepository();
    }
    
    // üîß SERVICIOS: Qu√© funcionalidades expone tu m√≥dulo
    public function registerServices(ModuleServiceRegistry $registry): void
    {
        // Exponer tu repositorio para que otros m√≥dulos lo usen
        $registry->register('mimodulo.repository', 'mimodulo', function($container) {
            return $this->repository;
        });
        
        // Exponer servicios espec√≠ficos
        $registry->register('mimodulo.processor', 'mimodulo', function($container) {
            return new MiModuloProcessor($this->repository);
        });
    }
    
         // üì° EVENTOS: Qu√© eventos escucha tu m√≥dulo
     public function registerEventListeners(ModuleEventDispatcher $dispatcher): void
     {
         // Escuchar cuando se crea un cliente (evento de otro m√≥dulo)
         $dispatcher->listen(\Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent::class, [$this, 'handleClientCreated']);
         
         // Escuchar eventos de pago (eventos globales de src/Events/ si existen)
         $dispatcher->listen(\GesPrender\Events\PaymentConfirmedEvent::class, [$this, 'handlePaymentConfirmed']);
         
         // üí° TIP: Para eventos de otros m√≥dulos espec√≠ficos, usar sus namespaces completos
         // $dispatcher->listen(\Backoffice\Modules\Whatsapp\Infrastructure\Events\MessageSentEvent::class, [$this, 'handleMessageSent']);
     }
    
    // ü™ù HOOKS: Puntos de extensi√≥n para otros m√≥dulos
    public function registerHooks(ModuleHookSystem $hooks): void
    {
        // Permitir que otros modifiquen datos antes de procesar
        $hooks->addFilter('mimodulo.before_process', [$this, 'validateData'], 5);
        
        // Permitir acciones despu√©s de procesar
        $hooks->addAction('mimodulo.after_process', [$this, 'logActivity'], 10);
    }
    
    // üì§ EVENTOS: Qu√© eventos puede disparar tu m√≥dulo
    public function getDispatchableEvents(): array
    {
        return [
            'MiModuloCreatedEvent',
            'MiModuloUpdatedEvent',
            'MiModuloProcessedEvent'
        ];
    }
    
    // ‚ÑπÔ∏è  INFO: Informaci√≥n del m√≥dulo
    public function getModuleInfo(): array
    {
        return [
            'name' => 'MiModulo',
            'version' => '1.0.0',
            'description' => 'Descripci√≥n de qu√© hace tu m√≥dulo',
            'namespace' => 'Backoffice\Modules\MiModulo',
            'path' => 'Backoffice/src/Modules/MiModulo',
            'dependencies' => ['clients'], // Si depende de otros m√≥dulos
            'services_exposed' => [
                'mimodulo.repository',
                'mimodulo.processor'
            ]
        ];
    }
    
    // üöÄ INICIO: Se ejecuta cuando se carga el m√≥dulo
    public function boot(): void
    {
        // Inicializaci√≥n del m√≥dulo
        do_action('mimodulo.module_loaded');
    }
    
    // üîö CIERRE: Se ejecuta cuando se desactiva el m√≥dulo
    public function shutdown(): void
    {
        // Limpieza cuando se desactiva el m√≥dulo
        do_action('mimodulo.module_shutdown');
    }
    
    // üéØ HANDLERS: M√©todos que responden a eventos
    
         /**
      * Responde cuando se crea un cliente
      */
     public function handleClientCreated(\Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent $event): void
    {
        $client = $event->getClient();
        
        // Tu l√≥gica personalizada aqu√≠
        error_log("MiModulo: Nuevo cliente creado - " . $client['name']);
        
        // Ejemplo: crear un registro relacionado
        $this->repository->save([
            'client_id' => $client['id'],
            'status' => 'pending',
            'created_at' => date('Y-m-d H:i:s')
        ]);
    }
    
    /**
     * Responde cuando se confirma un pago
     */
    public function handlePaymentConfirmed(\GesPrender\Events\PaymentConfirmedEvent $event): void
    {
        $studentId = $event->getStudentId();
        $amount = $event->getAmount();
        
        // Tu l√≥gica personalizada aqu√≠
        error_log("MiModulo: Pago confirmado - Student: {$studentId}, Amount: {$amount}");
    }
    
    // üéõÔ∏è FILTROS Y ACCIONES
    
    public function validateData(array $data): array
    {
        // Validar y modificar datos
        return $data;
    }
    
    public function logActivity(array $processedData): void
    {
        // Log de actividad
        error_log("MiModulo: Processed - " . json_encode($processedData));
    }
}

// üîß Clases de apoyo
class MiModuloProcessor
{
    private MiModuloRepository $repository;
    
    public function __construct(MiModuloRepository $repository)
    {
        $this->repository = $repository;
    }
    
    public function process(array $data): array
    {
        // L√≥gica de procesamiento
        return ['processed' => true, 'data' => $data];
    }
}
```

---

## üöÄ **Paso 2: Agregar Comunicaci√≥n a un M√≥dulo Existente**

### 2.1 Si tu m√≥dulo YA EXISTE, solo agrega comunicaci√≥n:

```php
// En tu caso de uso existente (ej: SetElement.php)
final class SetElement extends MiModuloRepository
{
    use TraitRequest;

    public function __construct() {
        // üî• AGREGAR: Inicializar comunicaci√≥n
        $this->initCommunicationSystem();
        $this->run();
    }

    public function run(): JsonResponse
    {
        try {
            $data = $this->getRequestData();
            
            // üî• AGREGAR: Aplicar filtros antes de procesar. Por si quiero que otro modulo pueda modificar $data antes de ejecutar la logica de este endpoint.
            if (function_exists('apply_filters')) {
                $data = apply_filters('mimodulo.before_process', $data);
            }
            
            // $this->save ser√≠a la acci√≥n de crear en DB. Est√° hecho as√≠ en este ejemplo para resumir el proceso, pero adaptar a como corresponda.
            $result = $this->save($data);
            
            // üî• AGREGAR: Disparar evento despu√©s de crear
            if (function_exists('dispatch')) {
                dispatch(new MiModuloCreatedEvent('mimodulo', [
                    'item' => $result,
                    'created_by' => $_SESSION['user_id'] ?? 'system'
                ]));
            }
            
            // üî• AGREGAR: Ejecutar acciones post-proceso
            if (function_exists('do_action')) {
                do_action('mimodulo.after_process', $result);
            }
            
            return new JsonResponse([
                'status' => true,
                'message' => 'Element created with communication',
                'data' => $result
            ], 201);
            
        } catch (\Throwable $th) {
            return self::ExceptionResponse($th, 'SetElement:action');
        }
    }
    
    // üî• AGREGAR: M√©todo para inicializar comunicaci√≥n
    private function initCommunicationSystem(): void
    {
        if (!function_exists('init_module_communication')) {
            $helpersPath = dirname(__DIR__, 4) . '/src/Communication/ModuleHelpers.php';
            if (file_exists($helpersPath)) {
                require_once $helpersPath;
                init_module_communication(true);
            }
        }
    }
}
```

---

## üöÄ **Paso 3: Crear Eventos Personalizados**

### 3.1 Crear tu archivo de eventos en Infrastructure:

```bash
# Crear directorio de eventos en tu m√≥dulo
mkdir -p Backoffice/src/Modules/MiModulo/Infrastructure/Events
```

```php
// Backoffice/src/Modules/MiModulo/Infrastructure/Events/MiModuloEvents.php
<?php #GesPrender Core Framework
declare(strict_types=1);
namespace Backoffice\Modules\MiModulo\Infrastructure\Events;

use GesPrender\Events\ModuleEvent;

class MiModuloCreatedEvent extends ModuleEvent
{
    public function getItem(): array
    {
        return $this->payload['item'];
    }
    
    public function getCreatedBy(): string
    {
        return $this->payload['created_by'] ?? 'system';
    }
}

class MiModuloUpdatedEvent extends ModuleEvent
{
    public function getItem(): array
    {
        return $this->payload['item'];
    }
    
    public function getUpdatedBy(): string
    {
        return $this->payload['updated_by'] ?? 'system';
    }
}

class MiModuloProcessedEvent extends ModuleEvent
{
    public function getProcessedData(): array
    {
        return $this->payload['processed_data'];
    }
    
    public function getProcessingTime(): float
    {
        return $this->payload['processing_time'] ?? 0.0;
    }
 }
 ```

### 3.2 Estructura Recomendada de Events en Infrastructure:

```
Backoffice/src/Modules/MiModulo/Infrastructure/
‚îú‚îÄ‚îÄ Communication/
‚îÇ   ‚îî‚îÄ‚îÄ ModuleCommunication.php # Comunicaci√≥n inter-modular
‚îú‚îÄ‚îÄ Events/
‚îÇ   ‚îú‚îÄ‚îÄ MiModuloEvents.php      # Todas las clases de eventos
‚îÇ   ‚îú‚îÄ‚îÄ Events.php              # Archivo central de documentaci√≥n y helpers
‚îÇ   ‚îî‚îÄ‚îÄ README.md               # Documentaci√≥n espec√≠fica de eventos (opcional)
‚îî‚îÄ‚îÄ MiModuloRepository.php      # Repository del m√≥dulo
```

### 3.3 Archivo Central de Events (recomendado):

```php
// Backoffice/src/Modules/MiModulo/Infrastructure/Events/Events.php
<?php #GesPrender Core Framework
declare(strict_types=1);
namespace Backoffice\Modules\MiModulo\Infrastructure\Events;

/**
 * Archivo central de eventos del m√≥dulo MiModulo
 * Facilita la importaci√≥n y documentaci√≥n de eventos
 */
class Events
{
    /**
     * Lista de todos los eventos disponibles en este m√≥dulo
     */
    public static function getAvailableEvents(): array
    {
        return [
            'MiModuloCreatedEvent' => MiModuloCreatedEvent::class,
            'MiModuloUpdatedEvent' => MiModuloUpdatedEvent::class,
            'MiModuloProcessedEvent' => MiModuloProcessedEvent::class,
        ];
    }
    
    /**
     * Obtener informaci√≥n de un evento espec√≠fico
     */
    public static function getEventInfo(string $eventClass): array
    {
        $info = [
            'class' => $eventClass,
            'module' => 'mimodulo',
            'namespace' => 'Backoffice\Modules\MiModulo\Infrastructure\Events',
            'description' => '',
            'payload_fields' => []
        ];
        
        switch ($eventClass) {
            case MiModuloCreatedEvent::class:
                $info['description'] = 'Disparado cuando se crea un elemento en MiModulo';
                $info['payload_fields'] = [
                    'item' => 'array - Datos del elemento creado',
                    'created_by' => 'string - Usuario que lo cre√≥'
                ];
                break;
        }
        
        return $info;
    }
}
```

### 3.4 Ventajas de Events en Infrastructure:

‚úÖ **Autonom√≠a del M√≥dulo**: Cada m√≥dulo es completamente independiente  
‚úÖ **Organizaci√≥n Clara**: Todos los eventos de un m√≥dulo est√°n en su carpeta  
‚úÖ **Namespaces Espec√≠ficos**: No hay conflictos entre m√≥dulos  
‚úÖ **F√°cil Mantenimiento**: Eventos y l√≥gica relacionada est√°n juntos  
‚úÖ **Autodocumentaci√≥n**: Cada m√≥dulo documenta sus propios eventos  

---

## üöÄ **Paso 4: Probar la Comunicaci√≥n**

### 4.1 Script de prueba r√°pida:

```php
// test_mi_modulo.php
<?php

require_once 'src/Communication/ModuleHelpers.php';
require_once 'src/Communication/ModuleManager.php';

echo "üß™ Probando comunicaci√≥n de MiModulo...\n";

try {
    // Inicializar sistema
    init_module_communication(true);
    
    // Crear manager y cargar m√≥dulos
    $manager = new \GesPrender\Communication\ModuleManager(
        get_module_service_registry(),
        get_module_event_dispatcher(),
        get_module_hook_system(),
        true
    );
    
    $loadedModules = $manager->discoverAndLoadModules();
    
    echo "‚úÖ M√≥dulos cargados: " . implode(', ', array_keys($loadedModules)) . "\n";
    
    // Verificar si tu m√≥dulo est√° cargado
    if ($manager->isModuleLoaded('MiModulo')) {
        echo "‚úÖ MiModulo cargado correctamente\n";
        
        // Probar servicio
        if (has_service('mimodulo.repository')) {
            $repo = module_service('mimodulo.repository');
            echo "‚úÖ Servicio mimodulo.repository disponible\n";
        }
        
                 // Disparar evento de prueba
         dispatch(new \Backoffice\Modules\MiModulo\Infrastructure\Events\MiModuloCreatedEvent('mimodulo', [
            'item' => ['id' => 'test123', 'name' => 'Test Item'],
            'created_by' => 'test_user'
        ]));
        
        echo "‚úÖ Evento MiModuloCreatedEvent disparado\n";
        
    } else {
        echo "‚ùå MiModulo NO cargado\n";
    }
    
} catch (Exception $e) {
    echo "‚ùå Error: " . $e->getMessage() . "\n";
}
```

### 4.2 Ejecutar prueba:

```bash
php test_mi_modulo.php
```

---

## üöÄ **Paso 5: Usar Servicios de Otros M√≥dulos**

### 5.1 En cualquier caso de uso, usar servicios externos:

```php
public function run(): JsonResponse
{
    try {
        // üî• USAR SERVICIO DE WHATSAPP
        if (has_service('whatsapp.sender')) {
            $whatsappSender = module_service('whatsapp.sender');
            $whatsappSender->sendMessage('+34666123456', 'Hola desde MiModulo!');
        }
        
        // üî• USAR SERVICIO DE CLIENTS
        if (has_service('clients.repository')) {
            $clientsRepo = module_service('clients.repository');
            // $clients = $clientsRepo->findAll();
        }
        
                 // üî• DISPARAR EVENTO QUE OTROS ESCUCHEN
         dispatch(new \Backoffice\Modules\MiModulo\Infrastructure\Events\MiModuloProcessedEvent('mimodulo', [
             'processed_data' => ['status' => 'completed'],
             'processing_time' => 2.5
         ]));
        
        return new JsonResponse(['status' => true]);
        
    } catch (\Throwable $th) {
        return self::ExceptionResponse($th, 'MiModulo:action');
    }
}
```

---

## üöÄ **Paso 6: Usar Hooks para Extensibilidad**

### 6.1 Permitir que otros m√≥dulos modifiquen tu comportamiento:

```php
public function processItem(array $data): array
{
    // ü™ù Permitir que otros m√≥dulos modifiquen los datos
    $data = apply_filters('mimodulo.before_process', $data);
    
    // Tu l√≥gica de procesamiento
    $result = $this->doProcessing($data);
    
    // ü™ù Permitir que otros m√≥dulos modifiquen el resultado
    $result = apply_filters('mimodulo.after_process', $result, $data);
    
    // üé¨ Ejecutar acciones que otros m√≥dulos pueden escuchar
    do_action('mimodulo.item_processed', $result, $data);
    
    return $result;
}
```

### 6.2 Desde otros m√≥dulos, conectarse a tus hooks:

```php
// En otro m√≥dulo
public function registerHooks(ModuleHookSystem $hooks): void
{
    // Modificar datos antes del procesamiento de MiModulo
    $hooks->addFilter('mimodulo.before_process', function($data) {
        $data['enhanced'] = true;
        return $data;
    });
    
    // Reaccionar cuando MiModulo procesa algo
    $hooks->addAction('mimodulo.item_processed', function($result, $originalData) {
        error_log("OtroModulo: MiModulo proces√≥ algo - " . json_encode($result));
    });
}
```

---

## üîó **Comunicaci√≥n Entre M√≥dulos - Importaci√≥n de Eventos**

### üéØ **Regla de Oro: Eventos en Infrastructure**

**‚úÖ Estructura correcta:**
```
Backoffice/src/Modules/[Modulo]/Infrastructure/Events/
```

**‚ùå NO usar src/Events/ para eventos espec√≠ficos de m√≥dulos**

### üí° **C√≥mo Importar Eventos de Otros M√≥dulos**

#### Opci√≥n 1: Import directo (recomendado)

```php
// En tu Infrastructure/Communication/ModuleCommunication.php
use Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent;
use Backoffice\Modules\Whatsapp\Infrastructure\Events\MessageSentEvent;

public function registerEventListeners(ModuleEventDispatcher $dispatcher): void
{
    // Escuchar eventos de otros m√≥dulos
    $dispatcher->listen(ClientCreatedEvent::class, [$this, 'handleClientCreated']);
    $dispatcher->listen(MessageSentEvent::class, [$this, 'handleMessageSent']);
}
```

#### Opci√≥n 2: Namespace completo (para casos espec√≠ficos)

```php
public function registerEventListeners(ModuleEventDispatcher $dispatcher): void
{
    // Usar namespace completo sin import
    $dispatcher->listen(\Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent::class, [$this, 'handler']);
}
```

### üìö **Descubrimiento de Eventos de Otros M√≥dulos**

```php
// Obtener eventos disponibles de un m√≥dulo espec√≠fico
$clientEvents = \Backoffice\Modules\Clients\Infrastructure\Events\Events::getAvailableEvents();
$whatsappEvents = \Backoffice\Modules\Whatsapp\Infrastructure\Events\Events::getAvailableEvents();

foreach ($clientEvents as $name => $class) {
    echo "Evento disponible: {$name} -> {$class}\n";
}

// Obtener informaci√≥n detallada de un evento
$eventInfo = \Backoffice\Modules\Clients\Infrastructure\Events\Events::getEventInfo(
    \Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent::class
);

echo "Descripci√≥n: " . $eventInfo['description'] . "\n";
echo "Payload: " . json_encode($eventInfo['payload_fields']) . "\n";
```

### ‚ö° **Buenas Pr√°cticas para Eventos entre M√≥dulos**

#### ‚úÖ **DO - Hacer:**

```php
// 1. Usar namespaces espec√≠ficos del m√≥dulo
use Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent;

// 2. Verificar si el evento existe antes de usarlo
if (class_exists('\Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent')) {
    $dispatcher->listen(ClientCreatedEvent::class, [$this, 'handler']);
}

// 3. Manejar errores si el m√≥dulo origen no est√° disponible
public function handleClientCreated($event): void
{
    if (!$event instanceof ClientCreatedEvent) {
        error_log("Evento inesperado recibido");
        return;
    }
    
    $client = $event->getClient();
    // Tu l√≥gica aqu√≠
}
```

#### ‚ùå **DON'T - No hacer:**

```php
// ‚ùå No usar eventos de src/Events/ para l√≥gica espec√≠fica de m√≥dulos
use GesPrender\Events\ClientCreatedEvent; // MALO

// ‚ùå No asumir que otros m√≥dulos est√°n disponibles
dispatch(new SomeOtherModuleEvent()); // Sin verificar

// ‚ùå No hardcodear dependencias de m√≥dulos
$this->requiresModules = ['clients', 'whatsapp']; // MALO, usar verificaci√≥n din√°mica
```

### üîç **Verificaci√≥n Din√°mica de M√≥dulos y Eventos**

```php
// En tu ModuleCommunication.php
public function registerEventListeners(ModuleEventDispatcher $dispatcher): void
{
    // Verificar si el m√≥dulo Clients est√° disponible
    if (class_exists('\Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent')) {
        $dispatcher->listen(
            \Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent::class, 
            [$this, 'handleClientCreated']
        );
        
        error_log("MiModulo: Registrado listener para ClientCreatedEvent");
    } else {
        error_log("MiModulo: M√≥dulo Clients no disponible, saltando registro de eventos");
    }
    
    // Lo mismo para WhatsApp
    if (class_exists('\Backoffice\Modules\Whatsapp\Infrastructure\Events\MessageSentEvent')) {
        $dispatcher->listen(
            \Backoffice\Modules\Whatsapp\Infrastructure\Events\MessageSentEvent::class,
            [$this, 'handleMessageSent']
        );
    }
}
```

### üìñ **Documentar Dependencias de tu M√≥dulo**

```php
public function getModuleInfo(): array
{
    return [
        'name' => 'MiModulo',
        'version' => '1.0.0',
        'description' => 'Descripci√≥n de tu m√≥dulo',
        
        // üî• IMPORTANTE: Documentar qu√© m√≥dulos/eventos usa
        'event_dependencies' => [
            'clients' => [
                'events' => ['ClientCreatedEvent', 'ClientUpdatedEvent'],
                'required' => false // o true si es obligatorio
            ],
            'whatsapp' => [
                'events' => ['MessageSentEvent'],
                'required' => false
            ]
        ],
        
        // Informaci√≥n para el auto-discovery
        'listens_to' => [
            \Backoffice\Modules\Clients\Infrastructure\Events\ClientCreatedEvent::class,
            \Backoffice\Modules\Whatsapp\Infrastructure\Events\MessageSentEvent::class,
        ],
        
        'dispatches' => [
            \Backoffice\Modules\MiModulo\Infrastructure\Events\MiModuloCreatedEvent::class,
        ]
    ];
}
```

---

## üîß **Troubleshooting**

### ‚ùå "No se encuentra el m√≥dulo"

**Problema:** El auto-discovery no encuentra tu m√≥dulo.

**Soluci√≥n:**
1. ‚úÖ Verifica que `ModuleCommunication.php` est√© en `Application/`
2. ‚úÖ Verifica el namespace: `Backoffice\Modules\[TuModulo]\Application`
3. ‚úÖ Ejecuta test: `php test_module_communication.php`

### ‚ùå "Function dispatch not found"

**Problema:** El sistema de comunicaci√≥n no est√° inicializado.

**Soluci√≥n:**
```php
// Agregar al inicio de tu caso de uso
private function initCommunicationSystem(): void
{
    if (!function_exists('init_module_communication')) {
        $helpersPath = dirname(__DIR__, 4) . '/src/Communication/ModuleHelpers.php';
        if (file_exists($helpersPath)) {
            require_once $helpersPath;
            init_module_communication(true);
        }
    }
}
```

### ‚ùå "Service not found"

**Problema:** El servicio no est√° registrado.

**Soluci√≥n:**
1. ‚úÖ Verifica que `registerServices()` registre el servicio
2. ‚úÖ Usa `has_service('nombre.servicio')` antes de `module_service()`
3. ‚úÖ Verifica que el m√≥dulo est√© cargado

### ‚ùå "Event not received"

**Problema:** El evento se dispara pero no llega.

**Soluci√≥n:**
1. ‚úÖ Verifica que `registerEventListeners()` registre el listener
2. ‚úÖ Verifica que el namespace del evento sea correcto
3. ‚úÖ Usa logging: `error_log("Event received: " . get_class($event))`

---

## üìö **Ejemplos Pr√°cticos Completos**

### üéØ **Ejemplo 1: M√≥dulo de Inventario que notifica por WhatsApp**

```php
// Cuando el stock es bajo, enviar WhatsApp autom√°tico
public function handleStockUpdate($productId, $newStock): void
{
    if ($newStock < 10) {
        // Disparar evento
        dispatch(new LowStockEvent('inventory', [
            'product_id' => $productId,
            'current_stock' => $newStock,
            'threshold' => 10
        ]));
        
        // O enviar directamente
        if (has_service('whatsapp.sender')) {
            $whatsapp = module_service('whatsapp.sender');
            $whatsapp->sendMessage('+34666123456', "‚ö†Ô∏è Stock bajo: Producto {$productId} solo tiene {$newStock} unidades");
        }
    }
}
```

### üéØ **Ejemplo 2: M√≥dulo de Auditor√≠a que escucha todo**

```php
// M√≥dulo que escucha todos los eventos para auditor√≠a
public function registerEventListeners(ModuleEventDispatcher $dispatcher): void
{
    $dispatcher->listen(\GesPrender\Events\ClientCreatedEvent::class, [$this, 'auditClientCreated']);
    $dispatcher->listen(\GesPrender\Events\PaymentConfirmedEvent::class, [$this, 'auditPayment']);
    $dispatcher->listen(\GesPrender\Events\MessageSentEvent::class, [$this, 'auditMessage']);
    // ... escuchar todos los eventos importantes
}

public function auditClientCreated(\GesPrender\Events\ClientCreatedEvent $event): void
{
    $this->repository->logAudit([
        'event_type' => 'client_created',
        'module_origin' => $event->getOriginModule(),
        'client_data' => $event->getClient(),
        'timestamp' => $event->timestamp->format('Y-m-d H:i:s'),
        'user_id' => $_SESSION['user_id'] ?? 'system'
    ]);
}
```

### üéØ **Ejemplo 3: M√≥dulo de Reportes que consume m√∫ltiples servicios**

```php
public function generateMonthlyReport(): array
{
    $report = [];
    
    // Obtener datos de clientes
    if (has_service('clients.repository')) {
        $clientsRepo = module_service('clients.repository');
        $report['total_clients'] = count($clientsRepo->findAll());
    }
    
    // Obtener datos de pagos
    if (has_service('payments.repository')) {
        $paymentsRepo = module_service('payments.repository');
        $report['total_revenue'] = $paymentsRepo->getTotalRevenue();
    }
    
    // Obtener estad√≠sticas de WhatsApp
    if (has_service('whatsapp.repository')) {
        $whatsappRepo = module_service('whatsapp.repository');
        $report['messages_sent'] = $whatsappRepo->getMessageCount();
    }
    
    return $report;
}
```

---

## üéâ **¬°Listo para Desarrollar!**

Con esta gu√≠a puedes:

‚úÖ **Crear m√≥dulos nuevos** con comunicaci√≥n  
‚úÖ **Conectar m√≥dulos existentes** entre s√≠  
‚úÖ **Usar servicios** de otros m√≥dulos  
‚úÖ **Escuchar y disparar eventos**  
‚úÖ **Crear puntos de extensi√≥n** con hooks  
‚úÖ **Debuggear problemas** comunes  

**üöÄ ¬°Tu m√≥dulo ya puede comunicarse con todo el ecosistema del framework!**

---

## üìû **Soporte**

Si tienes problemas:

1. **Ejecuta el test:** `php test_module_communication.php`
2. **Revisa logs:** Busca mensajes en error_log
3. **Verifica estructura:** Los archivos deben estar en las rutas correctas
4. **Consulta ejemplos:** Mira `Clients` y `Whatsapp` como referencia

---

## üöÄ CLI Integrado - Generaci√≥n Autom√°tica

### **Comando Simplificado**

El CLI de GesPrender ahora incluye **autom√°ticamente** el sistema de comunicaci√≥n en todos los m√≥dulos:

```bash
php coreshell make:module MiModulo  # ‚úÖ Incluye comunicaci√≥n por defecto
```

### **Estructura Generada**

Cada `make:module` crea autom√°ticamente:
- ‚úÖ **Infrastructure/Communication/ModuleCommunication.php** - Configuraci√≥n completa
- ‚úÖ **Infrastructure/Events/** - Eventos espec√≠ficos + registro central
- ‚úÖ **Application/SetElementWithCommunication.php** - Ejemplo funcional
- ‚úÖ **Estructura DDD completa** - Application, Domain, Infrastructure, Design

### **Auto-Discovery Compatible**

Los m√≥dulos generados son autom√°ticamente detectados por el `ModuleManager` sin configuraci√≥n adicional.

**Documentaci√≥n completa del CLI:** Ver `Docs/cli-integration.md`

**¬°Happy Coding!** üéØ 